---
layout: post
title:  "Ruby元编程"
date:   2018-06-25
categories: Ruby
---

# Ruby元编程

####《Ruby 元编程》介绍了33中元编程技巧。

***阅读本书可以学到对象类型、作用域、单件类、代码块等元编程概念，还能学到Rails的组织结构和工作原理，以及借助元编程编写领域专属语言。***

***元编程也有两面性：可以用元编程增强语言的功能，还可以创建领域专属语言；但是也可能陷入元编程的陷阱。元编程是一种容易让人迷惑的技术。***

### 第一章 元这个字眼
***元编程是编写能写代码的代码。***
```
内省(introspection)检测自身属于什么类，有没有某个方法，自己的父类是谁等等。
```

***元编程是编写能在运行时操作语言构件的代码。***

##### 1.3 元编程和Ruby Metaprogramming and Ruby

```
如果要操作语言构件，这些构件必须在运行时存在。
编写在运行时操作自身的代码，这称为动态元编程(dynamic metaprogramming),而代码生成器和编译器的那种方式称为静态元编程(static metaprogramming)。
```
### 第二章 星期一：对象模型

```
Ruby中，除了对象还有其他的语言构件，比如类(class)、模块(module)以及实例变量(instance variable)等。元编程(metaprogramming)操作的就是这些语言构件。
所有这些语言构件存在的系统称之为对象模型。对象模型是Ruby的灵魂。
```
##### 2.1 打开类

```
从某种意义上说，Ruby的class关键字更像是一个作用域操作符，而不是类型声明语句。
猴子补丁：覆盖原有类的方法。
猴子补丁是个贬义词，使用它确实存在风险。如果误用它是危险的（比如补丁已存在的方法）。
有时候我们需要使用它，尤其是希望改造已有类库的时候，它很有用。
```
##### 2.2 类的真相

```
Object#instance_variables ## 来查看对象包含的实例变量

与Java这样的静态语言不通，Ruby中对象的类和它的实例变量没有关系，当给实例变量赋值时，他们就突然出现了。因此，对于同一个类，你可以创建具有不同实例变量的对象。可以把Ruby中实例变量的名字和值理解为哈希表中的键/值对，每一个对象的键/值对都可能不同。

除了实例变量，对象还有方法。
Object#methods  ## 获得一个对象的方法列表
Object#instance_methods	   ## 获得一个对象的实例方法列表
Array#grep 	  ## 查询方法列表 obj.methods.grep(/my/) my开头的方法
如果可以撬开Ruby解释器并查看obj，你会注意到这个对象其实并没有真正存放一组方法。在其内部，一个对象仅包含它的实例变量以及一个对自身类的引用(因为每个对象都属于一个类，或者从面向对象的属于说，每个对象都是某个类的实例)。
共享同一个类的对象也共享同样的方法，因此方法必须存放在类中，而非对象中。
实例变量存放在对象中，而方法存放在类中。
一个对象的实例方法其实就是其类的实例方法。
```
***总结一下：一个对象的实例变量存在于对象本身之中，而一个对象的方法存在于对象自身的类中。这就是同一个类的对象共享同样的方法，而不共享实例变量的原因。***

***Ruby对象模型最重要的知识：类本身也是对象。***

```
Ruby编程的灵活性：其他的语言只允许你读取类的相关信息，而Ruby允许你在运行时修改这些信息。
Class.instance_methods(false)    # => 参数false在这里表示忽略继承的方法
Ruby的类继承自它的超类。
Array.superclass     # => Object
Object.superclass	 # => BasicObject
BasicObject.superclass # => nil
BasicObject是Ruby对象体系中的根节点，它只有少数几个方法。
Class类的超类是Module(模块),也就是说每个类都是一个模块。准确的说，类就是带有三个方法(new、allocate、superclass)的增强模块，这三个方法能让你按照一定的层次创建对象。
实际上，在Ruby中，类与模块这两个概念太接近了，完全可以用任意一个代表另一个。保留两个概念的主要原因就是为了获得代码的清晰性，让代码的意图显得更加明确。
如果希望把自己的代码包含（include）到别的代码中，就应该使用模块；如果希望某段代码被实例化或者被继承，就应该用类。

像普通的对象一样，类也可以通过引用来访问。
my_class = MyClass   # my_class和MyClass都是对同一个Class类的实例的引用，唯一区别在于，my_class是一个变量，而MyClass是一个常量。
```
***换句话，就像类不过是对象而已，类名无非就是常量。***

```
任何以大写字母开头的引用（包括类名和模块名）都是常量。
在代码中，常量像文件系统一样组织成树形结构，其中模块和类就像目录，而常量则像文件。像文件系统一样，只要不在同一个目录下，不同文件可以有相同的文件名。甚至可以像文件系统一样用路径来引用一个常量。
常量的路径用双冒号进行间隔。::
Module类还有一个实例方法和一个类型方法，名字都叫constants。Module#constants方法返回当前范围内的所有常量，就如同文件系统中的ls一样。
Module.constants方法返回当前程序中所有顶层的常量，其中也包括类名。
Module.nesting返回当前代码所在的路径。
```

```
对象和类的小结
什么是对象？对象就是一组实例变量外加一个指向其类的引用。对象的方法并不存在于对象本身，而是存在于对象的类中。在类中，这些方法被称为类的实例方法。
什么是类？类就是一个对象（Class类的一个实例）外加一组实例方法和一个对其超类的引用。Class类是Module类的子类，因此类也是一个模块。
```

***load方法和require方法，load用于加载代码，require用于导入类库。require对每个文件只加载一次，而load方法在每次调用时都会再次运行所加载的文件。***

##### 2.4 调用方法时发生了什么？

1. 找到这个方法;这个过程称为方法查找。
2. 执行这个方法;为了做到这点，Ruby要用到一个称为self的东西。

***接收者（receiver）和祖先链（ancestors chain）***
```
接收者就是你调用方法所在的对象。
祖先链就是从一个类找到它的超类，然后再找到超类的超类，依次类推，直到找到BasicObject类(Ruby类体系结构的根节点)。在这个过程中，经历的类路径就是该类的祖先链。
```

***一句话概括方法查找过程：Ruby首先在接收者的类中查找，然后再顺着祖先链向上查找，直到找到这个方法。***

***查找方法的方式：向右一步，再向上。***

```
从Ruby2.0开始，还可以用另外一种方式把模块插入一个类的祖先链中：使用prepend方法。它的功能与include相似，不过这个方法会把模块插入祖先链中包含它的该类的下方，而不像include方法那样插入上方。每次include或prepend一个模块时，如果该模块已经存在于祖先链中，那么Ruby会忽略这个包含(include或prepend)指令。一个模块只会在一条祖先链中出现一次。
```
```
私有方法同时遵守两条规则：首先，如果调用方法的接收者不是自己，就必须明确指明接收者；其次，私有方法只能通过隐性的接收者调用。根据这两条规则，你只能在自身中调用私有方法。这条综合的规则称为私有规则。
可以调用从超类中继承来的私有方法么？可以，因为调用继承来的方法不用明确指明接收者。
Ruby程序开始运行时，Ruby解释器会创建一个名为main的对象作为当前对象。
```
```
细化：与打开类不同，细化在默认情况下并不生效。细化的作用范围只在该模块内部有效。细化和打开类的作用相似，区别在于细化不是全局性的。
细化只在两种场合有效：1.refine代码块内部；2.从using语句的位置开始到模块结束(如果是在模块内部调用using语句)，或者到文件结束(如果是在顶层上下文中调用using)。
在细化有限的作用域范围内，其作用跟打开类(或者叫猴子补丁)是一样的。
细化一个类就像把一个补丁直接打到原有代码上一样。
Object.private_methods  # 获取私有方法
Object.methods == Object.public_methods
```
##### 2.6 对象模型小结
1. 对象由一组实例变量和类的引用组成。
2. 对象的方法存在于对象所属的类中(对类来说是实例方法)。
3. 类本身是Class类的对象。类的名字也是一个常量。
4. Class类是Module的子类。一个模块基本上就是由一组方法组成的包。类除了具有模块的特性外，还可以被实例化(使用new方法)，或者按照一定的层次结构来组织(使用superclass方法)。
5. 常量像文件系统一样，是按照树形结构组织的。其中，模块和类的名字扮演目录的角色，其他普通的常量则扮演文件的角色。
6. 每个类都有一个祖先链，这个链从每个类自己开始，向上直到BasicObject类结束。
7. 调用方法时，Ruby首先向右找到接收者所属的类，然后向上查找祖先链，直到找到该方法或者达到链的顶端为止。
8. 在类中包含一个模块(使用include方法)时，这个模块会被插入祖先链中，位置就在类的正上方；而使用prepend方法包含一个模块时，这个模块也会被插入祖先链中，位置在类的正下方。
9. 调用一个方法时，接收者会扮演self的角色。
10. 定义一个模块(或类)时，该模块会扮演self的角色。
11. 实例变量永远被认定为self的实例变量。
12. 任何没有明确指定接收者的方法调用，都当做是调用self的方法。
13. 细化就像在原来的类上添加了一块补丁，而且它会覆盖正常的方法查找。此外，细化只在程序的部门区域生效：从using语句的位置开始，直到模块结束，或者直到文件结束。

### 第三章 星期二：方法

##### 3.2 动态方法 Dynamic Methods

***调用一个方法实际上是给一个对象发送一条消息。***

```
# 动态派发
使用send方法调用方法：send(:my_method, 3)。方法名既可以使用字符串，也可以使用符号。剩下的参数和代码块会直接传递给调用的方法。
为什么使用send方法，这是因为在send方法里，想调用的方法名变成了参数，这样就可以在代码运行的最后一刻决定调用哪个方法。这个技巧称为动态派发(Dynamic Dispatch)。
符号和字符串：符号用于表示事务的名字——尤其是跟元编程相关的名字，比如方法名。符号是不可修改的，你可以修改字符串，但是不能修改符号。因此，符号特别适合表示方法名。谁都不希望方法名被修改吧？
不管怎样，符合和字符串是很容易相互转换的：to_sym/to_s
```

***使用send方法比较漂亮的例子`[50]`,Pry的例子。***

```
Object#send方法功能非常强大，可以使用send调用任何方法，包括私有方法。
可以使用public_send方法，它和send方法相似，但它会尊重接收者的隐私。
```

```
# 动态定义方法
可以用Module#define_method()方法随时定义一个方法，只需要提供一个方法名和充当方法主体的块。
用Module#define_method方法代替def关键字定义方法的一个重要原因是：define_method方法允许在运行时决定方法的名字。
如果给String#grep方法传递一个块(block)，那么对每个满足正则表达式的元素，这个块都会被执行。
```
***动态定义方法比较漂亮的例子`[54]`,Computer的例子。***

##### 3.3 method_missing方法

```
# 幽灵方法和动态代理
如果Ruby在继承链中找不到方法时，会在接收者对象上调用一个名为method_missing的方法。method_missing方法时BasicObject的一个私有实例方法，而所有对象都继承BasicObject类，所以它对所有的对象都可用。
覆写method_missing方法可以让你调用实际上并不存在的方法。
# 幽灵方法
被method_missing方法处理的消息，从调用者角度来看，跟普通方法没什么区别，而实际上接收者并没有对应的方法，这称为幽灵方法(Ghost Method)。
通常幽灵方法发挥的都是锦上添花的作用，不过也有些对象的功能几乎完全依赖于它。这些对象通常是一些封装对象，他们封装的可以是另一个对象、web服务或者是用其他语言编写的代码。这些对象通过method_missing方法收集方法调用，并把这些调用转发到被封装的对象上。
respond_to?(:my_method)  # 检查是否存在my_method方法
respond_to_missing?(:my_method)		# 检查是否存在my_method的幽灵方法(是个私有方法)
```
***method_missing方法比较漂亮的例子`[57]`,Hashie::Mash的例子。***

***method_missing方法比较漂亮的例子`[59]`,Ghee的例子。***

```
# 白板类(Blank Slate)
拥有极少方法的类称为白板类，它拥有的方法比object类还要少。
如果不特别指定超类，创建的类默认继承自Object类，它是BasicObject的子类。如果你需要一个白板类，可以直接从BasicObject类继承。
# 删除方法
删除一个方法有两种途径：一种是用Module#undef_method方法，另一种是用Module#remove_method方法。Module#undef_method会删除所有(包括继承而来的)方法；Module#remove_method只删除接收者自己的方法，而保留继承来的方法。
```
***白板类比较漂亮的例子`[68]`,builder的例子(xml)。***

***在可以使用动态方法的时候，尽量使用动态方法；除非必须使用幽灵方法，否则尽量不要使用它。***

### 第四章 星期三：代码块（Blocks）

```
# 代码块
块可以用来控制作用域(scope)。作用域是变量和方法可用性范围。
可调用对象：块、proc和lambda。
代码块可以用大括号定义，也可以用do...end关键字定义。通常，只有一行的块用大括号，而多行的块用do...end。
只有调用一个方法时，才可以定义一个块。块会被直接传递给这个方法，该方法可以用yield关键字调用这个块。
块可以有自己的参数。
Kernel#block_given?方法可判断当前的方法调用是否包含块。
代码块不是浮在空中的，它不可能孤立地运行。运行代码需要一个执行环境：局部变量、实例变量、self等。
代码块包含代码，也包含一组绑定。
代码块是闭包的。换句话说，代码块可以获取局部绑定，并一直带着它们。
# 作用域 Scope
作用域到处都是绑定。
Ruby中作用域之间是截然分开的：一旦进入一个新的作用域，原先的绑定会被替换为一组新的绑定。
全局变量($)可以在任何作用域中访问。谁都可以修改全局变量，能不使用全局变量就尽量不要使用。可以使用顶级变量(@)代替全局变量。
# 作用域门
程序会在三个地方关闭作用域，同时打开一个新的作用域：1. 类定义 2. 模块定义 3. 方法。
三种情况关键字：class、module、def作为标志。每个关键字对应一个作用域门(Scope Gate)。
# 扁平化作用域：穿越作用域门
穿越作用域门方式：Class.new、Module.new、Module#define_method都可以。闭包上常用的法术。
如果两个作用域挤压在一起，它们就可以共享各自的变量，也可以成为扁平化作用域(Flat Scope)。
# 共享作用域
想在一组方法之间共享一个变量，但是又不希望其他方法访问这个变量，就可以把这些方法定义在那个变量所在的扁平作用域里。
```
***在类定义和模块定义中的代码会立即执行。***

***嵌套文法作用域(nested lexical scopes)`82`，或者叫扁平化作用域(flattening the scope)***

##### 4.4 instance_eval方法
```
# instance_eval 方法
BasicObject#instance_eval方法，它在一个对象的上下文执行块。
传递给instance_eval方法的代码块称为上下文探针(Context Probe)，因为它像是一个深入到对象中的代码片段，并可以对那个对象进行操作。
# instance_exec 方法
instance_eval的双胞胎兄弟instance_exec。它比instance_eval稍微灵活一点，允许代码块传入参数。
# 洁净室
洁净室只是一个用来执行快的环境。一个理想的化的洁净室是不应该有任何方法或者实例变量的(因为这样的话，其中的方法名和实例变量名有可能和代码块从其环境带来的名字冲突)。因此，BasicObject的实例往往用来充当洁净室，因为它是白板类，几乎没有任何方法。
```

***打包代码，以后调用：块、proc(是由块转换来的对象)、lambda(proc的变种)、方法***

##### 4.5.1 Proc 对象
```
Proc就是由块转换来的对象。使用Proc.new创建一个Proc，以后就可以用Proc#call方法来执行这个由代码块转换的对象。这个技巧称为延迟执行(Deferred Evaluation)。
还有几种方法创建proc。Ruby有两个内核方法可以把块转换成Proc:lambda方法和proc方法。
还可以使用带刺的*lanbda操作符创建lambda。
4中代码块转换为Proc的方式：Proc.new、lambda{}、proc{}、->(x){}。
# & 操作符
代码块就像是方法额外的匿名参数。
&操作符的含义是：这是一个Proc对象，我想把它当成代码块来使用。去掉&操作符，就能再次得到一个Proc对象。
可以使用&操作符再把Proc转换成代码块。
yield是指代码块。
```
***&操作符把Proc对象转换成代码块。***

***延迟执行的例子`89`***

```
# Proc与Lambda的对比
用lambda方法创建的Proc与用其他方式创建的Proc有一些细微却重要的差别。用lambda方法创建的Proc称为lambda，而用其他方式创建的则称为proc。(可以用Proc#lambda?方法检测Proc是不是lambda。)
Proc与lambda的重要差别有两个。第一个与return关键字有关，另一个则与参数检验有关。
# Proc、Lambda和return
在lambda中，return仅仅表示从这个lambda中返回。
在proc中，return的行为则有所不同。它不是从proc中返回，而是从定义proc的作用域中返回。
# Proc、Lambda和参数数量
proc和lambda的第二个差别来自它们检查参数的方式。如果调用lambda时的参数数量不对，就会抛出ArgumentError错误；而proc则会把传来的参数调整成自己期望的参数形式。
整体而言，lambda更直观，因为它更像是一个方法。它对参数数量要求严格，而且在调用return时确实只是从代码中返回。可以把lambda作为第一选择，除非需要使用proc的某些特殊功能。
```

```
# Method 对象
Method对象类似于代码块或者lambda。实际上，可以通过Method#to_proc方法把Method对象转换为Proc。还可以通过define_method方法把代码块转换为方法。它们一个重要区别：lambda在定义它的作用域中执行(它是一个闭包)，而Method对象会在它自身所在对象的作用域中执行。
# 自由方法
自由方法(unbound method)跟普通方法类似，不过它从最初定义它的类或者模块中脱离了。通过调用Method#unbind方法，可以把一个方法变成自由方法。也可以直接调用Module#instance_method方法获得一个自由方法。
可以把自由方法绑定到一个对象上，使之再次成为一个Method对象。具体做法是使用UnboundMethod#bind方法把UnboundMethod对象绑定到一个对象上。从某个类中分离出来的UnboundMethod对象只能绑定在该类及其子类的对象上，不过从模块分离出来的UnboundMethod对象在Ruby2.0之后不受这个限制。还可以把UnboundMethod对象传给Module#define_method方法，从而实现绑定。
```
***Active Support 的例子`95`***

```
# 可调用对象小结 Callable Objects Wrap-Up
可调用对象是可以执行的代码片段，而且它们有自己的作用域。可调用对象由以下几种：
1. 代码块（它们不是真正的对象，但它们是“可调用的”）：在定义它们的作用域中执行。
2. proc：Proc类的对象跟代码一样，也在定义自身的作用域中执行。
3. lambda：也是Proc类的对象，但是跟普通的proc有细微的差别。它跟块和proc一样都是闭包，因此也在定义自身的作用域中执行。
4. 方法：绑定于一个对象，在所绑定对象的作用域中执行。它们也可以与这个作用域解除绑定，然后再重新绑定到另一个对象的作用域上。
```

##### 4.6 编写领域专属语言（DSL）Writing a Domain-Specific Language

***第一个领域专属语言 DSL `97`***

##### 4.8 小结

```
1. 作用域门和Ruby 管理作用域的方式。
2. 利用扁平作用域与共享作用域让绑定穿越作用域。
3. 在对象的作用域中执行代码(通过instance_eval方法或instance_exec方法)，在洁净室中执行代码。
4. 在代码块和对象(Proc)之间互相转换。
5. 在方法和对象(Method或UnboundMethod对象)之间相互转换。
6. 可调用对象(代码块、Proc、lambda及普通方法)之间的区别。
7. 编写自己的领域专属语言。
```

### 第五章 星期四：类定义
本章主要学习两种法术：类宏`117`可以用来修改类，环绕别名`134`可以在其他方法前后封装额外代码。为了最大限度的发挥这些法术的作用，本章还介绍单件类(singleton class)，这是Ruby最优雅的特性之一。

```
# 提醒
1. 类不过是增强的模块，因此本章学到的所有知识也都可以应用于模块。所有讲”类定义“的内容，也是讲”模块定义“的。
2. 本章是本书最深奥的内容。
```

##### 5.1 揭秘类定义

```
# 当前类
不管处在Ruby程序的哪个位置，总存在一个对前对象：self。同样，也总是有一个当前类(或模块)存在。定义一个方法时，那个方法将成为当前类的一个实例方法。
```





































。