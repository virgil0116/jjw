[link](http://)##设计模式
###OO基础
* 抽象
* 封装
* 多态
* 继承

###OO原则
1. 封装变化
2. 多用组合，少用继承
3. 针对接口编程，不针对实现编程
4. 为交互对象之间的松耦合而努力
5. 类应该对扩展开放，对修改关闭
6. 依赖抽象，不要依赖具体类
7. 只和朋友交谈
8. 别找我，我会找你
9. 类应该只有一个改变的理由

###模式描述
######策略 —— 封装可以互换的行为，并使用委托决定使用哪一个；
######适配器 —— 改变一个类或多个类的接口；(包装一个对象,并提供不同的接口)
######迭代器 —— 提供一个方式来遍历集合，而无需暴露集合的实现；
######外观 —— 简化一群类的接口；(包装许多对象以简化他们的接口)
######组合 —— 客户可以将对象的集合以及个别的对象一视同仁；
######观察者 —— 当某个对象改变时，允许一群对象能被通知到；
######装饰着 —— 包装一个对象，并提供额外的行为;
######代理 —— 包装一个对象，并控制对它的访问;

###1、策略模式 —— 行为型
**策略模式**定义了算法簇,分别封装起来,让他们之间可以互相替换,此模式让算法的变化独立于使用算法的客户;

###2、观察者模式 —— 行为型
**观察者模式**定义了对象之间的一对多依赖,这样一来,当一个对象状态改变时,它的所有依赖者都会收到通知并自动更新;

主题(Subject)->观察者(Observer)
###3、装饰者模式 —— 结构型
**装饰着模式**动态的将责任附加到对象上;若要扩展,装饰者提供了比继承更有弹性的替代方案;
###4、工厂模式 —— 创建型
**工厂方法模式**定义了一个创建对象的接口,但由子类决定要实例化的是哪一个;工厂方法让类把实例化推迟到子类中;

**抽象工厂模式**提供一个接口,用于创建相关或一来对象的家族,而不需要明确指定具体类;
###5、单件模式 —— 创建型
**单件模式**确保一个类只有一个实例,并提供一个全局访问点;
###6、命令模式 —— 行为型
**命令模式**将"请求"封装成对象,以便使用不同的请求、队列或者日志来参数化其他对象;命令模式也支持可撤销的操作;
###7、适配器与外观模式
**适配器模式**将一个对象包装起来以改变其接口;将一个接口装换成另一个接口;

**外观模式**提供了一个统一的接口,用来访问子系统中的一群接口;外观定义了一个高层接口,让子系统更容易使用;(家庭影院例子)

###8、模板方法
在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下重新定义算法中的某些步骤。
######模板方法 —— 子类决定如何实现算法中的某些步骤
#####策略 —— 封装可互换的行为，然后使用委托来决定使用哪一个行为
#####工厂方法 —— 哪个具体类


###9、迭代器与组合模式 (管理良好的集合)
####迭代器模式(Iterator Pattern)
迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的标示。
####单一职责
一个类应该只有一个引起变化的原因(尽量让每个类保持单一职责)
####组合模式(Composite Pattern)
组合模式允许你将对象组合成树形机构来表现"整体/部分"层次结构。组合模式能让客户以一致的方式处理个别对象以及组合对象。

使用组合结构，我们把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和对象之间的差别。



###10、状态模式(事物的状态)
基本常识：策略模式和状态模式是双胞胎，在出生时才分开。

**状态模式**允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
####要点
* 状态模式允许一个对象基于内部状态而拥有不同的行为。
* 和程序状态机不同(PSM)不同，状态模式用类代表状态。
* Context会将行为委托给当前状态对象。
* 通过将每个状态封装进一个类，我们把以后需要做的任何改变局部化了。
* 状态模式和策略模式由相同的类图，但是他们的意图不同。
* 策略模式通常会用行为或算法类配置Context类。
* 状态模式允许Context随着状态的改变而改变行为。
* 状态模式可以由State类或Context类控制。
* 使用状态模式通常会 导致设计中类的数目增加。
* 状态类可以被多个Context实例共享。

###11、代理模式
**代理模式**为另一个对象提供一个替身或占位符以控制对这个对象的访问。
* 远程代理
* 虚拟代理
* 保护代理
* 缓存代理
* 同步代理
* 防火墙代理
* 写入时复制代理

######装饰着模式为对象加上行为,而代理则是控制访问;

###12、复合模式(模式的模式Compound Pattern)
**复合模式**组合两个或两个以上的模式,组成一个解决方案,解决一再发生的一般性问题。

######MVC是复合模式
* 策略模式			C
* 观察者模式			M-V
* 组合模式			V


###13、真实世界中的模式(与模式相处)
**模式**是在某情境(context)下,针对某问题的某种解决方案;




###23种设计模式
#####创建型
1. 工厂方法模式
2. 抽象工厂模式
3. 单例模式
4. 建造者模式
5. 原型模式
#####结构型(类和对象被组合以建立新的结构或新的功能)
1. 适配器模式						-ok
2. 装饰者模式						
3. 代理模式
4. 外观模式						-ok
5. 桥接模式
6. 组合模式
7. 享元模式
#####行为型(对象之间的沟通与互连)
1. 策略模式					
2. 模板方法模式
3. 观察者模式
4. 迭代子模式
5. 责任链模式
6. 命令模式
7. 备忘录模式
8. 状态模式
9. 访问者模式
10. 中介者模式
11. 解释器模式

#####讲解
* 外观模式(Facade)

属于结构型，就是要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行交互。外观模式提供了一个高层次的接口使得子系统更易于使用。最大特点是**将细粒度的对象包装成粗粒度的对象**。

	* 外观角色(Facade)：客户端可以调用这个角色的方法。此角色知晓相关的子系统的功能和责任。
	* 子系统角色：可以同时有一个或多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。
	优点：简化接口，将多个类的复杂操作隐藏在背后。引入外观，客户只需要与外观角色打交道，降低了系统的耦合度；提供了一个访问子系统的入口，但并不影响用户直接使用子系统类；降低了大型软件系统中的编译依赖，并简化不同平台之间的移植过程。
	缺点：不能很好的限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性；在不引入抽象外观类的情况下架，增加新的子系统可能需要修改外观类或客户端的源代码，违背了"开闭原则"。
	
每一个子系统都可以被客户端直接调用，或者被外观角色调用。

外观模式主要是减少了客户与子系统之间的关联对象，使客户对子系统的使用变得简单，也实现了客户与子系统之间的松耦合关系。(通常只需要一个外观类，so可以使用单例模式)

* 适配器模式(Adapter)

属于结构性，把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起。

	* 目标角色(Target)：就是期待得到的接口。
	* 源角色(Adapee)：现在需要适配的接口。
	* 适配器角色(Adapter)：适配器类是本模式的核心。
	* 类适配器：继承被适配类，同时实现目标接口。
	* 对象适配器：组合包含被适配对象，同时实现目标接口。(对象适配器更加灵活一些)
	
	优点：解决接口的不兼容问题，将目标类与适配者解耦。
	
	总结：适配器模式也是一种包装模式，与Decorator装饰模式都有包装的功能；此外对象适配器的显示委托(类适配器的隐式委托)与Proxy代理模式类似；书中提倡适配器模式不适合在设计阶段使用，它是一种补偿模式，在系统后期扩展、修改时使用较好；当需要修改一个已经上线的接口时，适配器模式可能是最适合的；

#####总结
两个模式都是作用于用户与真实被使用的类或系统之间，作为一个中间层，起到让用户间接地调用真实的类的作用。

外观和适配器都是对现存系统的封装。外观定义新的接口，而适配器是复用一个原有的接口，适配器是使两个已有的接口协同工作，外观则是为现存的系统提供一个更为方便的访问接口。适配器是适配的是对象。外观针对的是整个系统。

外观模式注重简化接口，适配器模式注重转换接口。适配器是事后设计，外观是事前设计，外观模式的对象粒度更大；
	






















